<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Video Scroll - GSAP</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
        }

        /* The container that holds the video and pins it */
        .video-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video {
            /* Make video cover the screen */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 100%;
            min-height: 100%;
            object-fit: cover;
            /* Important for performance */
            /* will-change: contents; */
        }

        /* 
           This is the "Scroll Track" - the height of this determines 
           how long you have to scroll to finish the video.
           We will set this dynamically or you can set a fixed height here.
            GSAP will pin the .video-container inside this track.
        */

        /* Overlays for demo purposes */
        .overlay-text {
            position: relative;
            z-index: 10;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            /* Allow clicks to pass through to tests if needed */
            pointer-events: none;
            mix-blend-mode: difference;
            /* Makes text visible on any background */
        }

        h1 {
            font-size: 5rem;
            text-transform: uppercase;
            letter-spacing: -2px;
            font-weight: 800;
            opacity: 0;
            /* Animated in by GSAP */
            transform: translateY(50px);
        }

        p {
            font-size: 1.5rem;
            margin-top: 20px;
            opacity: 0;
            transform: translateY(30px);
        }

        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            opacity: 0.7;
            animation: bounce 2s infinite;
            z-index: 20;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translate(-50%, 0);
            }

            50% {
                transform: translate(-50%, 10px);
            }
        }

        /* Extra content below to show normal scrolling resumes */
        .content-section {
            height: 100vh;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            border-top: 1px solid #333;
        }
    </style>
</head>

<body>

    <!-- 
      PERMANENT LAG FIX INSTRUCTIONS:
      1. This code now uses a "Canvas" to draw the video frames, which typically looks smoother.
      2. It also pre-downloads the entire video into memory (Blob) before starting to fix network lag.
      
      *** THE FINAL BOTTLENECK ***
      If it still stutters, it is 100% the VIDEO ENCODING.
      To fix it permanently, you MUST re-encode your video to have "Keyframes (GOP) of 1".'
      
      Run this simple command in your terminal on your video file:
      ffmpeg -i input.mp4 -movflags faststart -vcodec libx264 -crf 23 -g 1 -pix_fmt yuv420p output_smooth.mp4
      
      Then use 'output_smooth.mp4' in this file.
    -->

    <div class="loader">
        <div class="loader-text">Loading High-Res Video... 0%</div>
    </div>

    <div class="video-container" id="video-wrapper">
        <canvas id="video-canvas"></canvas>
    </div>

    <!-- Hidden video element for source -->
    <video id="hidden-video" playsinline muted preload="auto" style="display: none;"></video>

    <div class="overlay-text" id="slide-1">
        <h1>Ultimate Smoothness</h1>
        <p>Canvas Rendering + Blob Buffering</p>
    </div>

    <div class="overlay-text" id="slide-2">
        <h1>Precision Control</h1>
        <p>Frame-by-frame exactness.</p>
    </div>

    <div class="overlay-text" id="slide-3">
        <h1>Cinematic</h1>
        <p>The best experience possible.</p>
    </div>

    <div class="content-section">
        <h1>Content Resumes</h1>
    </div>

    <div class="scroll-indicator">Scroll Down â†“</div>

    <script>
        gsap.registerPlugin(ScrollTrigger);

        const canvas = document.querySelector("#video-canvas");
        const ctx = canvas.getContext("2d");
        const video = document.querySelector("#hidden-video");
        const loader = document.querySelector(".loader");
        const loaderText = document.querySelector(".loader-text");

        // Use a high-quality video (or your own)
        // Note: This specific URL is a standard MP4. For best results, use a locally optimized file.
        const videoUrl = "teaser.mp4";

        // 1. PRELOAD VIDEO AS BLOB (Removes Network Lag)
        // ------------------------------------------------
        const req = new XMLHttpRequest();
        req.open('GET', videoUrl, true);
        req.responseType = 'blob';

        req.onprogress = function (e) {
            if (e.lengthComputable) {
                const percent = Math.floor((e.loaded / e.total) * 100);
                loaderText.innerText = `Loading High-Res Video... ${percent}%`;
            }
        };

        req.onload = function () {
            if (this.status === 200) {
                const videoBlob = this.response;
                const vid = URL.createObjectURL(videoBlob);
                video.src = vid;

                // Once src is set, wait for metadata
                video.onloadedmetadata = initScrollAnimation;
            }
        };
        req.onerror = function () {
            // Fallback if Blob fails (CORS issues etc)
            video.src = videoUrl;
            video.onloadedmetadata = initScrollAnimation;
        };
        req.send();


        // 2. INITIALIZE SCROLL ANIMATION
        // ------------------------------------------------
        function initScrollAnimation() {
            // Remove loader
            gsap.to(loader, { opacity: 0, duration: 0.5, onComplete: () => loader.style.display = "none" });

            // Set canvas size to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Resize canvas on window resize to cover screen properly (object-fit: cover equivalent)
            function resizeCanvas() {
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const videoRatio = video.videoWidth / video.videoHeight;
                const screenRatio = vw / vh;

                if (screenRatio > videoRatio) {
                    canvas.style.width = "100%";
                    canvas.style.height = "auto";
                } else {
                    canvas.style.width = "auto";
                    canvas.style.height = "100%";
                }
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();


            // SCROLLTRIGGER SETUP
            let tl = gsap.timeline({
                scrollTrigger: {
                    trigger: ".video-container",
                    start: "top top",
                    end: "+=1200%", // Very long scroll for slow, detailed playback
                    pin: true,
                    scrub: 1 // Moderate scrub for responsiveness
                }
            });

            // We tween a virtual object "playhead" from 0 to video.duration
            let playhead = { frame: 0 };

            tl.to(playhead, {
                frame: video.duration,
                ease: "none",
                onUpdate: () => {
                    // Update video time
                    // We use a small epsilon to ensure we don't hit the exact end which sometimes causes flicker
                    video.currentTime = playhead.frame;
                }
            });

            // 3. THE RENDER LOOP (The "Magic" Bit)
            // --------------------------------------
            // Instead of relying on auto-paint, we force draw the video frame 
            // whenever the browser is ready to paint a new frame.

            function render() {
                // Determine if we need to draw (only if video has data)
                if (video.readyState >= 2) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                }
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);


            // TEXT ANIMATIONS (Same as before)
            gsap.fromTo("#slide-1", { opacity: 1 }, {
                scrollTrigger: { trigger: ".video-container", start: "top top", end: "+=50%", scrub: true },
                opacity: 0, y: -50
            });

            let slide2 = gsap.timeline({
                scrollTrigger: { trigger: ".video-container", start: "25% top", end: "55% top", scrub: true }
            });
            slide2.fromTo("#slide-2", { opacity: 0, y: 50 }, { opacity: 1, y: 0, duration: 1 })
                .to("#slide-2", { opacity: 0, y: -50, duration: 1 }, "+=0.5");

            let slide3 = gsap.timeline({
                scrollTrigger: { trigger: ".video-container", start: "65% top", end: "90% top", scrub: true }
            });
            slide3.fromTo("#slide-3", { opacity: 0, y: 50 }, { opacity: 1, y: 0 });
        }
    </script>
</body>

</html>
